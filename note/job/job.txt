from pyspark.sql.utils import AnalysisException
from datetime import datetime

# Configuraci√≥n de tablas a validar
BRONZE_TABLES = [
    "workspace.default.credits",
    "workspace.default.titles",
    "workspace.default.netflix_titles"
]

# Umbrales de validaci√≥n
MIN_ROWS = 100  # M√≠nimo de filas esperadas por tabla
MAX_NULL_PERCENTAGE = 50  # M√°ximo porcentaje de nulos permitido en columnas clave

print("=" * 70)
print(f"üîç VALIDACI√ìN DE TABLAS BRONZE - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("=" * 70)

# Diccionario para almacenar resultados
validation_results = {}
all_passed = True

try:
    for table_name in BRONZE_TABLES:
        print(f"\nüìä Validando tabla: {table_name}")
        print("-" * 70)
        
        try:
            # 1. Verificar que la tabla existe
            df = spark.table(table_name)
            
            # 2. Contar registros
            row_count = df.count()
            print(f"   ‚úì Registros encontrados: {row_count:,}")
            
            # 3. Validar cantidad m√≠nima de registros
            if row_count == 0:
                print(f"   ‚ùå ERROR: La tabla est√° vac√≠a")
                all_passed = False
                validation_results[table_name] = {
                    "status": "FAILED",
                    "rows": row_count,
                    "error": "Tabla vac√≠a"
                }
                continue
            elif row_count < MIN_ROWS:
                print(f"   ‚ö†Ô∏è  ADVERTENCIA: Menos de {MIN_ROWS} registros ({row_count})")
            
            # 4. Verificar esquema
            columns = df.columns
            print(f"   ‚úì Columnas encontradas: {len(columns)}")
            print(f"     {', '.join(columns[:5])}{'...' if len(columns) > 5 else ''}")
            
            # 5. Validar que no haya duplicados totales
            distinct_count = df.distinct().count()
            duplicate_percentage = ((row_count - distinct_count) / row_count) * 100
            print(f"   ‚úì Registros √∫nicos: {distinct_count:,} ({100-duplicate_percentage:.1f}%)")
            
            if duplicate_percentage > 10:
                print(f"   ‚ö†Ô∏è  ADVERTENCIA: {duplicate_percentage:.1f}% de duplicados")
            
            # 6. Validar columnas clave
            key_column = columns[0] 
            null_count = df.filter(df[key_column].isNull()).count()
            null_percentage = (null_count / row_count) * 100
            print(f"   ‚úì Nulos en '{key_column}': {null_count:,} ({null_percentage:.1f}%)")
            
            if null_percentage > MAX_NULL_PERCENTAGE:
                print(f"   ‚ùå ERROR: Demasiados nulos en columna clave '{key_column}'")
                all_passed = False
                validation_results[table_name] = {
                    "status": "FAILED",
                    "rows": row_count,
                    "error": f"Muchos nulos en {key_column}"
                }
                continue
            
            # 7. Verificar tipos de datos (ejemplo)
            schema_info = df.dtypes
            print(f"   ‚úì Tipos de datos validados: {len(schema_info)} columnas")
            
            # Marcar como exitoso
            validation_results[table_name] = {
                "status": "PASSED",
                "rows": row_count,
                "distinct": distinct_count,
                "duplicates_pct": duplicate_percentage,
                "null_pct": null_percentage
            }
            print(f"   ‚úÖ Validaci√≥n exitosa")
            
        except AnalysisException as ae:
            print(f"   ‚ùå ERROR: La tabla no existe o no es accesible")
            print(f"      Detalle: {str(ae)}")
            all_passed = False
            validation_results[table_name] = {
                "status": "FAILED",
                "rows": 0,
                "error": "Tabla no existe"
            }
        
        except Exception as e:
            print(f"   ‚ùå ERROR INESPERADO: {str(e)}")
            all_passed = False
            validation_results[table_name] = {
                "status": "FAILED",
                "rows": 0,
                "error": str(e)
            }
    
    # Resumen final
    print("\n" + "=" * 70)
    print("üìã RESUMEN DE VALIDACI√ìN")
    print("=" * 70)
    
    total_rows = 0
    for table, results in validation_results.items():
        status_icon = "‚úÖ" if results["status"] == "PASSED" else "‚ùå"
        table_short = table.split(".")[-1]
        print(f"{status_icon} {table_short:20} | {results['rows']:>10,} filas | {results['status']}")
        if results["status"] == "PASSED":
            total_rows += results["rows"]
    
    print("-" * 70)
    print(f"Total de registros v√°lidos: {total_rows:,}")
    print("=" * 70)
    
    # Decisi√≥n final
    if all_passed:
        print("\n‚úÖ VALIDACI√ìN EXITOSA: Todas las tablas Bronze tienen datos v√°lidos")
        print("üöÄ Puedes continuar con el pipeline de transformaci√≥n")
        
        # Retornar c√≥digo de √©xito 
        # dbutils.notebook.exit("SUCCESS")
        
    else:
        error_tables = [t for t, r in validation_results.items() if r["status"] == "FAILED"]
        error_msg = f"‚ö†Ô∏è VALIDACI√ìN FALLIDA: {len(error_tables)} tabla(s) con errores: {', '.join([t.split('.')[-1] for t in error_tables])}"
        print(f"\n{error_msg}")
        print("üõë Revisa los datos antes de continuar con el pipeline")
        
        # Lanzar excepci√≥n para que el job falle
        raise ValueError(error_msg)

except Exception as e:
    print("\n" + "=" * 70)  
    print("‚ùå ERROR CR√çTICO EN LA VALIDACI√ìN")
    print("=" * 70)
    print(f"Mensaje: {str(e)}")
    print("\nüõë El job se detendr√°. Revisa los logs y soluciona los errores.")
    raise e
